# LOCK
#### Concept
```
脏读 Dirty Read
    一个事物读到另一个事物未提交的数据
    脏读发生的条件 是需要将数据库隔离级别设计为 READ UNCOMMITTED, 数据库默认隔离级别为READ REPEATABLE,所以生产环境一般不会发生脏读
    特殊应用场景：replication的salve节点，并且该节点的查询不需要返回特别精确的数据
不可重复读
    一个事物多次读取同一数据，发现前后数据不一致，因为读取数据期间，另一个事物对这一数据进行了DML操作
    不可重复读发生条件是 数据库隔离级别设置为 READ COMMITTED
    InnoDB存储引擎通过next-key lock算法，避免了不可重复读问题

覆盖更新
    一个事物操作的更新操作会被另一个事物的更新操作覆盖，从而导致数据不一致
死锁
    两个或两个以上事物，因争夺锁资源而造成一种相互等待的现象
    解锁死锁最简单方法就是超时，设置超时时间，一旦超过阈值遍进行回滚
Next-Key Lock算法
    对于索引的扫描，不仅锁住扫描到的索引列，还锁住这些索引所覆盖的范围，这个范围内的插入是不允许的，因此避免了不可重复读的问题
```

### 乐观锁 悲观锁
乐观锁是一种思想，它其实并不是一种真正的『锁』，它会先尝试对资源进行修改，在写回时判断资源是否进行了改变，如果没有发生改变就会写回，否则就会进行重试，在整个的执行过程中其实都没有对数据库进行加锁；
悲观锁就是一种真正的锁了，它会在获取资源前对资源进行加锁，确保同一时刻只有有限的线程能够访问该资源，其他想要尝试获取资源的操作都会进入等待状态，直到该线程完成了对资源的操作并且释放了锁后，其他线程才能重新操作资源；
乐观锁不会存在死锁的问题，但是由于更新后验证，所以当冲突频率和重试成本较高时更推荐使用悲观锁，而需要非常高的响应速度并且并发量非常大的时候使用乐观锁就能较好的解决问题，在这时使用悲观锁就可能出现严重的性能问题；在选择并发控制机制时，需要综合考虑上面的四个方面（冲突频率、重试成本、响应速度和并发量）进行选择。
