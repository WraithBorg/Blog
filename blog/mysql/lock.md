# LOCK
#### Concept
```
脏读 Dirty Read
    一个事物读到另一个事物未提交的数据
    脏读发生的条件 是需要将数据库隔离级别设计为 READ UNCOMMITTED, 数据库默认隔离级别为READ REPEATABLE,所以生产环境一般不会发生脏读
    特殊应用场景：replication的salve节点，并且该节点的查询不需要返回特别精确的数据
不可重复读
    一个事物多次读取同一数据，发现前后数据不一致，因为读取数据期间，另一个事物对这一数据进行了DML操作
    不可重复读发生条件是 数据库隔离级别设置为 READ COMMITTED
    InnoDB存储引擎通过next-key lock算法，避免了不可重复读问题

覆盖更新
    一个事物操作的更新操作会被另一个事物的更新操作覆盖，从而导致数据不一致
死锁
    两个或两个以上事物，因争夺锁资源而造成一种相互等待的现象
    解锁死锁最简单方法就是超时，设置超时时间，一旦超过阈值遍进行回滚
Next-Key Lock算法
    对于索引的扫描，不仅锁住扫描到的索引列，还锁住这些索引所覆盖的范围，这个范围内的插入是不允许的，因此避免了不可重复读的问题
```

### 乐观锁 悲观锁
乐观锁是一种思想，它其实并不是一种真正的『锁』，它会先尝试对资源进行修改，在写回时判断资源是否进行了改变，如果没有发生改变就会写回，否则就会进行重试，在整个的执行过程中其实都没有对数据库进行加锁；
悲观锁就是一种真正的锁了，它会在获取资源前对资源进行加锁，确保同一时刻只有有限的线程能够访问该资源，其他想要尝试获取资源的操作都会进入等待状态，直到该线程完成了对资源的操作并且释放了锁后，其他线程才能重新操作资源；
乐观锁不会存在死锁的问题，但是由于更新后验证，所以当冲突频率和重试成本较高时更推荐使用悲观锁，而需要非常高的响应速度并且并发量非常大的时候使用乐观锁就能较好的解决问题，在这时使用悲观锁就可能出现严重的性能问题；在选择并发控制机制时，需要综合考虑上面的四个方面（冲突频率、重试成本、响应速度和并发量）进行选择。


####
一致性读（ 一 Consistent Reads） 事务利用MVCC进行的读取操作称之为一致性读，或者一致性无锁读，有的地方也称之为快照读。
所有普通的SELECT语句（plain SELECT）在READ COMMITTED、REPEATABLE READ隔离级别下都算是一致性读 


共享锁，英文名：Shared Locks，简称S锁。在事务要读取一条记录时，需要先获取该记录的S锁。 
独占锁，也常称排他锁，英文名：Exclusive Locks，简称X锁。在事务要改动一条记录时，需要先获取该记录的X锁。



如果事务T1首先获取了一条记录的X锁之后，那么不管事务T2接着想获取该记录的S锁还是X锁都会被阻塞，直到事务T1提交。
所以我们说S锁和S锁是兼容的，S锁和X锁是不兼容的，X锁和X锁也是不兼容的，
#### 锁定读的语句
对读取的记录加S锁： SELECT ... LOCK IN SHARE MODE;

	也就是在普通的SELECT语句后边加LOCK IN SHARE MODE，如果当前事务执行了该语句，
	那么它会为读取到的记录加S锁，这样允许别的事务继续获取这些记录的S锁（比方说别的事务
	也使用SELECT ... LOCK IN SHARE MODE语句来读取这些记录），但是不能获取这些记录的X锁（比方说使用SELECT ... FOR UPDATE语句
	来读取这些记录，或者直接修改这些记录）。
	如果别的事务想要获取这些记 录的X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的S锁释放掉。


对读取的记录加X锁：SELECT ... FOR UPDATE;

	也就是在普通的SELECT语句后边加FOR UPDATE，如果当前事务执行了该语句，那么它会为读取到的记录加X锁，
	这样既不允许别的事务获取这些记录的S锁（比方说别的事务使用SELECT ... LOCK IN SHARE MODE语句来读取这些记录），
	也不允许获取这些记录的X锁（比方也说使用SELECT ... FOR UPDATE语句来读取这些记录，或者直接修改这些记录）。
	如果别的事务想要获取这些记录的S锁或 者X锁，
	那么它们会阻塞，直到当前事务提交之后将这些记录上的X锁释放掉。


给表加的锁也可以分为共享锁（S锁）和独占锁（X锁）
意向锁（英文名：Intention Locks）

意向共享锁，英文名：Intention Shared Lock，简称IS锁。当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁。 
意向独占锁，英文名：Intention Exclusive Lock，简称IX锁。当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁。


IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，
以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是 兼容的，IX锁和IX锁是兼容的



















